

#' simulate various scenarios in the form of a dataset for survClust method. 
#'
#' @param k integer, number of clusters to be simulate. (k >=2)
#' @param k_size vector, size of \code{k} clusters 
#' @param n_features number fo features to simulate
#' @param mu vector, means of \code{k} cluster 
#' @param sd vector, sd of \code{k} cluster
#' @param perc_inform percentage of informative features. Out of these \code{perc_inform/2} will be simulated as distinct and associated with survival, and remaining half as distinct and carrying no association with survival 
#' @param my_seed set a seed to reporoduce results. The seed is set locally and will not affect global settings
#'
#' @return A matrix of size \code{sum(k_size) * n_features} exhibiting \code{k} unique clusters
#' @export
#'
#' @examples
#' sim_mat <- simulate_data_type(k=3, k_size = rep(50,3), n_features = 150, mu = c(-1.5,0,1.5), sd = rep(1,3),perc_inform = 0.10)
#' 
#' 
simulate_data_type <- function(k, k_size, n_features, mu, sd, perc_inform, my_seed=NULL, permute=FALSE){
    
    #check whether all parameters for all k have been specified
    check_flag = purrr::map_lgl(c(length(k_size), length(mu), length(sd)), function(x) x==k)
    
    #only proceed if all have the same length as k
    if(all(check_flag)){
        
        #total number of samples in matrix - sum of size of all clusters
        n = sum(k_size)
        
        # p informative features
        p <- round(n_features * perc_inform)
        
        #remaining noisy features (q)
        q <- n_features - p
        
        # if permute then split the informative features that are associated with survival and those that are distinct only
        if(permute){p <- round(p/2)}
        
        # create a matrix with k clusters 
        # pmap iterates over k_size, mu and sd and returns k matrices of size k_sizexp
        mat_a_list <- purrr::pmap(list(k_size, mu, sd), 
                         function(kx, mux, sdx){
                             if(!is.null(my_seed)){set.seed(my_seed)}
                             matrix(rnorm(kx*p, mux, sdx), ncol=p)})
        
        #collapse all k-matrices to get a matrix of nxp
        mat_a <- do.call(rbind, mat_a_list)
        
        #rest simulate q feeatures as noise
        if(!is.null(my_seed)){set.seed(my_seed)}
        mat_b <- matrix(rnorm(n*q), ncol=q)
        
        #combine informative and non informative matrix
        mat <- cbind(mat_a, mat_b)
        
        #if permute, simulate the remaining features as dicinct bu breaking down the asscoiation with survival 
        
        if(permute){
            permute_idx<-sample(1:n,n)
            p2 = n_features - (p+q)
            mat_a_list <- purrr::pmap(list(k_size, mu, sd), 
                                 function(kx, mux, sdx){ 
                                     if(!is.null(my_seed)){set.seed(my_seed+1)}
                                     matrix(rnorm(kx*p2, mux, sdx), ncol=p2)})
            mat_a <- do.call(rbind, mat_a_list)
            
            #same as above but here we break the feature association with survival
            mat = cbind(mat,mat_a[permute_idx,])
        }
        
        #add dimension labels 
        rownames(mat) = paste0("S", 1:n)
        colnames(mat) = paste0("F", 1:n_features)
       
        return(mat)
    }
    
    else{ message("parameters should be specified for all k k_size, mu, sd, n_size.")
        break}
    
}


#' Simulate survival data from an exponential distribution from given median survival rates
#'
#' @param k integer, number of clusters to be simulate. (k >=2)
#' @param k_size vector, size of \code{k} clusters 
#' @param med_surv_times median survival rates for each of the \code{k} clusters
#' @param max_survival maximum survival time for follow up
#' @param my_seed set a seed to reproduce results. The seed is set locally and will not affect global settings
#'
#' @return a data.frame with samples as rows and survival time and events as columns. Sample names as rownames are auto generated by appending S to each row number.  
#'
#' @examples simulate_surv_dat(k=3, k_size = rep(50,3), med_surv_times=c(4.5, 3.25, 2), max_survival = 10)
simulate_surv_dat <- function(k, k_size, med_surv_times, max_survival, my_seed=NULL){
    
    #total number of samples in matrix - sum of size of all clusters
    n = sum(k_size)
    
    #median of an exponential distribution is log(2)/lambda
    
    med_surv_k <- purrr::map_dbl(med_surv_times, function(x) log(2)/x ) 
    
    surv_distribution_k <- purrr::map2(k_size, med_surv_k, 
                                       function(nx, ratex){
                                           if(!is.null(my_seed)){set.seed(my_seed)}
                                       rexp(nx, rate=ratex)})
    
    censor_events_k <- purrr::map(k_size, function(nx){
        if(!is.null(my_seed)){set.seed(my_seed)}
            runif(nx,0,max_survival)})

    surv_times_k <- purrr::map2(surv_distribution_k, censor_events_k, 
                                function(x,y) pmin(x,y)) 
    
    surv_event_k <- purrr::map2(surv_times_k, surv_distribution_k, 
                                function(x,y) if_else(x==y, 1, 0))
    
    #survdat <- cbind(do.call(rbind, surv_times_k), do.call(rbind, surv_event_k))
    survdat <- data.frame(time = surv_times_k %>% unlist(), event = surv_event_k %>% unlist())
    
    rownames(survdat) = paste0("S", 1:n)
    return(survdat)
}
